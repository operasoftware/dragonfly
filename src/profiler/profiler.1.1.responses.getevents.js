// Autogenerated by hob
window.cls || (window.cls = {});
cls.Profiler || (cls.Profiler = {});
cls.Profiler["1.1"] || (cls.Profiler["1.1"] = {});

cls.Profiler["1.1"].Events = function(arr)
{
  /**
    * Represents the smallest `Interval` which is large enough to cover all the
    * `Intervals` of each individual `Event` in the list.
    *
    * Is not set if `eventList` is empty.
    */
  this.interval = arr[0] ? new cls.Profiler["1.1"].Interval(arr[0], this) : null;
  /**
    * List of `Events`. The `Events` are ordered according to the start time of
    * their `Intervals` (increasing order).
    */
  this.eventList = (arr[1] || []).map(function(item)
  {
    return new cls.Profiler["1.1"].Event(item);
  });
};

cls.Profiler["1.1"].Interval = function(arr)
{
  /**
    * The start of the `Interval`. If not present, this is an left-open
    * `Interval` ([-inf, N]).
    */
  this.start = arr[0];
  /**
    * The end of the `Interval`. If not present, this is an right-open
    * `Interval` ([N, +inf]).
    */
  this.end = arr[1];
};

cls.Profiler["1.1"].Event = function(arr)
{
  /**
    * The type of `Event`. Some `Events` carry additional information relevant
    * to their type.
    */
  // cls.Profiler["1.1"].Event.EventType
  this.type = arr[0];
  /**
    * The time spent on this task. (Self-time). This time takes place at some
    * (unknown) point in the `Interval`.
    *
    * Does not include `overhead`.
    */
  this.time = arr[1];
  /**
    * Profiling overhead. This is the time spent doing things which would
    * normally not happen if we had not been profiling, e.g. storing the
    * selector text for CSS selector `Events`.
    *
    * The overhead takes place at some (unknown) point in the `Interval`.
    */
  this.overhead = arr[2];
  /**
    * Number of hits on this `Event`.
    */
  this.hits = arr[3];
  /**
    * The `Interval` in which the `Event` took place. An `Event` may consume time
    * across multiple time slices (e.g. thread evaluation) without requiring
    * *all* the time in that `Interval`.
    *
    * The `time` field contains the time actually spent working on the `Event`.
    * There is no exact start and end time for `Events` which are spread across
    * time slices, because the self-time spent is fragmented across the
    * `Interval`.
    *
    * We can therefore only know that the `time` spent on this `Event` happened
    * some time in this `Interval`, but not exactly where. (It would be
    * possible to expose each fragment of execution, of course, but the amount
    * of data required to represent this would be to large to handle).
    *
    * The start of the `Interval` represents the first time we started working
    * on this `Event`. The end of the `Interval` represents the last time we
    * were done working on this `Event`.
    */
  this.interval = arr[4] ? new cls.Profiler["1.1"].Interval(arr[4], this) : null;
  /**
    * The non-zero ID of this `Event`.
    */
  this.eventID = arr[5];
  /**
    * The parent `Event` ID, or not set if this is a top-level `Event`.
    */
  this.parentEventID = arr[6];
  /**
    * The number of immediate children (not grandchildren) for this `Event`.
    */
  this.childCount = arr[7];
  /**
    * Aggregated `time` for all children, including `time` for this `Event`.
    */
  this.aggregatedTime = arr[8];
  /**
    * Aggregated `overhead` for all children, including `overhead` for this
    * `Event`.
    */
  this.aggregatedOverhead = arr[9];
  /**
    * Additional information for `CSS_SELECTOR_MATCHING` `Events`.
    */
  this.cssSelectorMatching = arr[10] ? new cls.Profiler["1.1"].CssSelectorMatchingEvent(arr[10], this) : null;
  /**
    * Additional information for `SCRIPT_THREAD_EVALUATION` `Events`.
    */
  this.scriptThreadEvaluation = arr[11] ? new cls.Profiler["1.1"].ScriptThreadEvaluationEvent(arr[11], this) : null;
  /**
    * Additional information for `DOCUMENT_PARSING` `Events`.
    */
  this.documentParsing = arr[12] ? new cls.Profiler["1.1"].DocumentParsingEvent(arr[12], this) : null;
  /**
    * Additional information for `CSS_PARSING` `Events`.
    */
  this.cssParsing = arr[13] ? new cls.Profiler["1.1"].CssParsingEvent(arr[13], this) : null;
  /**
    * Additional information for `SCRIPT_COMPILATION` `Events`.
    */
  this.scriptCompilation = arr[14] ? new cls.Profiler["1.1"].ScriptCompilationEvent(arr[14], this) : null;
  /**
    * Additional information for `PAINT` `Events`.
    */
  this.paint = arr[15] ? new cls.Profiler["1.1"].PaintEvent(arr[15], this) : null;
};

cls.Profiler["1.1"].CssSelectorMatchingEvent = function(arr)
{
  /**
    * The selector text, e.g. "#foo .bar".
    */
  this.selector = arr[0];
};

cls.Profiler["1.1"].ScriptThreadEvaluationEvent = function(arr)
{
  /**
    * What kind of thread the `Event` represents.
    */
  // cls.Profiler["1.1"].ScriptThreadEvaluationEvent.ScriptThreadType
  this.scriptThreadType = arr[0];
  /**
    * If `scriptThreadType` is `EVENT`, this field will contain the event name,
    * e.g. 'load'.
    *
    * In all other cases, this field is not set.
    */
  this.eventName = arr[1];
};

cls.Profiler["1.1"].DocumentParsingEvent = function(arr)
{
  /**
    * The URL of the document that was parsed.
    */
  this.url = arr[0];
};

cls.Profiler["1.1"].CssParsingEvent = function(arr)
{
  /**
    * The URL of the stylesheet that was parsed. If the stylesheet is inlined
    * in another document, that document is used as the URL.
    */
  this.url = arr[0];
};

cls.Profiler["1.1"].ScriptCompilationEvent = function(arr)
{
  /**
    * Describes the origin of the script.
    */
  // cls.Profiler["1.1"].ScriptCompilationEvent.ScriptType
  this.scriptType = arr[0];
  /**
    * The URL of the stylesheet that was parsed. If the stylesheet is inlined
    * in another document, that document is used as the URL.
    */
  this.url = arr[1];
};

cls.Profiler["1.1"].PaintEvent = function(arr)
{
  /**
    * The `Area` that was painted, in document coordinates relative the upper
    * left corner of the view.
    */
  this.area = arr[0] ? new cls.Profiler["1.1"].Area(arr[0], this) : null;
};

/**
  * Defines an `Area` by its top-left corner and width/height.
  */
cls.Profiler["1.1"].Area = function(arr)
{
  this.x = arr[0];
  this.y = arr[1];
  this.w = arr[2];
  this.h = arr[3];
  /**
    * The scroll offsets of the view in which area is defined.
    *
    * @since 1.1
    */
  this.ox = arr[4];
  this.oy = arr[5];
};

