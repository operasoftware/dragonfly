message <span class="message">CreateRequestArg</span>
{
  <span class="comment">/**
    * The Window to perform the request in. (The events triggered by this
    * command will appear to come from this Window).
    */</span>
  required <span class="number">uint32</span> windowID = 1;
  <span class="comment">/**
    * The URL to request.
    */</span>
  required <span class="string">string</span> url = 2;
  <span class="comment">/**
    * The HTTP method, e.g. "GET", "POST".
    */</span>
  required <span class="string">string</span> method = 3;
  <span class="comment">/**
    * Set HTTP headers for this request. When HeaderPolicy NORMAL is chosen,
    * Opera will set reasonable default headers. With HeaderPolicy NORMAL, the
    * following headers can not be set by the caller:
    * 
    * - Accept-Charset
    * - Accept-Encoding
    * - Cache-Control
    * - Connection
    * - Cookie
    * - Cookie2
    * - Date
    * - Expect
    * - Host
    * - If-Range
    * - Pragma
    * - Range
    * - TE
    * - Trailer
    * - Upgrade
    * - User-Agent
    * - Via
    * 
    * Use either HeaderPolicy OVERWRITE, or REPLACE to set these headers.
    */</span>
  repeated Header headerList = 4;
  {
    <span class="comment">/**
      * The name of the HTTP header, for instance "Accept-Charset".
      */</span>
    required <span class="string">string</span> name = 1;
    <span class="comment">/**
      * The value of the HTTP header, for instance "utf-8" when using
      * Accept-Charset, or "text/html; charset=utf8" for Content-Type.
      */</span>
    required <span class="string">string</span> value = 2;
  }
  optional Payload payload = 5;
  {
    <span class="comment">/**
      * The mime type of this payload.
      */</span>
    required <span class="string">string</span> mimeType = 1;
    <span class="comment">/**
      * The bytes to use as the payload. If this field is set, the stringData
      * can not also be set.
      */</span>
    optional <span class="string">bytes</span> byteData = 3;
    <span class="comment">/**
      * The string to use as the payload. This is an alternative to using bytes
      * directly. If this field is set, byteData can not also be set.
      */</span>
    optional <span class="string">string</span> stringData = 2;
  }
  <span class="comment">/**
    * Controls how custom headers are handled.
    */</span>
  optional HeaderPolicy headerPolicy = 6 [default = 1];
  {
    <span class="comment">/**
      * Let's Opera choose request headers depending on how the resource is fetched.
      * Custom headers will be set but only if allowed.
      */</span>
    <span class="enum">NORMAL</span> = 1;
    <span class="comment">/**
      * Similar to NORMAL but any header in headerList will overwrite those chosen by Opera.
      */</span>
    <span class="enum">OVERWRITE</span> = 2;
    <span class="comment">/**
      * Replaces all headers with the custom ones. Care must be taken as illegal requests can
      * easily be created with this. It is primarly used for re-running a previous request with
      * the same or slighly altered headers.
      */</span>
    <span class="enum">REPLACE</span> = 3;
  }
  <span class="comment">/**
    * Override the global reload policy for this resource.
    */</span>
  optional ReloadPolicy reloadPolicy = 7 [default = 1];
  {
    <span class="comment">/**
      * Do not interfere with caching policy. This means there might
      * be no OnRequest-events from a certain URL-load if the resource
      * is cached.
      */</span>
    <span class="enum">DEFAULT</span> = 1;
    <span class="comment">/**
      * Load resources in full from the server, even if the resource is
      * unchanged and could be fetched from cache.
      */</span>
    <span class="enum">NO_CACHE</span> = 2;
  }
  <span class="comment">/**
    * Override the global request content mode for this resource.
    */</span>
  optional ContentMode requestContentMode = 8;
  {
    <span class="comment">/**
      * Indicates how to send the payload.
      */</span>
    optional Transport transport = 1 [default = 4];
    {
      <span class="comment">/**
        * Send the payload as a string.
        * 
        * Selecting this transport mode  will automatically enable decoding,
        * and the string will automatically converted to the correct character
        * encoding.
        * 
        * If this transport mode is used an unsuitable content type, the payload
        * will not be sent (without errors).
        */</span>
      <span class="enum">STRING</span> = 1;
      <span class="comment">/**
        * Send the payload as bytes. When this transport mode is chosen, character
        * conversion will not be performed. If the payload contains text data, it
        * will be sent in its original encoding.
        */</span>
      <span class="enum">BYTES</span> = 2;
      <span class="comment">/**
        * Send the payload as a base64-encoded data URI in the string field. When
        * this transport mode is chosen, character conversion will not be performed.
        * If the payload contains text data, it will be sent in its original encoding.
        */</span>
      <span class="enum">DATA_URI</span> = 3;
      <span class="comment">/**
        * Do not send the payload at all.
        */</span>
      <span class="enum">OFF</span> = 4;
    }
    <span class="comment">/**
      * Decode the data (for instance, decompress it, decrypt it, etc). This is
      * unrelated to character encoding.
      */</span>
    optional <span class="boolean">bool</span> decode = 2 [default = false];
    <span class="comment">/**
      * Even if other conditions are met, do not send the payload if it
      * exceeds the specified amout (in bytes).
      * 
      * By default, only payloads under one megabyte are sent.
      */</span>
    optional <span class="number">uint32</span> sizeLimit = 3 [default = 1000000];
  }
  <span class="comment">/**
    * Override the global response content mode for this resource.
    */</span>
  optional ContentMode responseContentMode = 9;
  {
    <span class="comment">/**
      * Indicates how to send the payload.
      */</span>
    optional Transport transport = 1 [default = 4];
    {
      <span class="comment">/**
        * Send the payload as a string.
        * 
        * Selecting this transport mode  will automatically enable decoding,
        * and the string will automatically converted to the correct character
        * encoding.
        * 
        * If this transport mode is used an unsuitable content type, the payload
        * will not be sent (without errors).
        */</span>
      <span class="enum">STRING</span> = 1;
      <span class="comment">/**
        * Send the payload as bytes. When this transport mode is chosen, character
        * conversion will not be performed. If the payload contains text data, it
        * will be sent in its original encoding.
        */</span>
      <span class="enum">BYTES</span> = 2;
      <span class="comment">/**
        * Send the payload as a base64-encoded data URI in the string field. When
        * this transport mode is chosen, character conversion will not be performed.
        * If the payload contains text data, it will be sent in its original encoding.
        */</span>
      <span class="enum">DATA_URI</span> = 3;
      <span class="comment">/**
        * Do not send the payload at all.
        */</span>
      <span class="enum">OFF</span> = 4;
    }
    <span class="comment">/**
      * Decode the data (for instance, decompress it, decrypt it, etc). This is
      * unrelated to character encoding.
      */</span>
    optional <span class="boolean">bool</span> decode = 2 [default = false];
    <span class="comment">/**
      * Even if other conditions are met, do not send the payload if it
      * exceeds the specified amout (in bytes).
      * 
      * By default, only payloads under one megabyte are sent.
      */</span>
    optional <span class="number">uint32</span> sizeLimit = 3 [default = 1000000];
  }
}
